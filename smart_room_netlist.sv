/* Generated by Yosys 0.57+0 (git sha1 cec48c6abdb4493515330e17c97625675fc1583c, g++ 15.2.1 -O2 -flto=auto -ffat-lto-objects -fexceptions -fstack-protector-strong -m64 -march=x86-64 -mtune=generic -fasynchronous-unwind-tables -fstack-clash-protection -fcf-protection -mtls-dialect=gnu2 -fno-omit-frame-pointer -mno-omit-leaf-frame-pointer -fPIC -O3) */

(* dynports =  1  *)
(* hdlname = "full_adder" *)
(* src = "full_adder.sv:1.1-33.10" *)
module \$paramod\full_adder\width=s32'00000000000000000000000000000101 (a, b, cin, s, cout);
  (* src = "full_adder.sv:4.27-4.28" *)
  input [4:0] a;
  wire [4:0] a;
  (* src = "full_adder.sv:5.27-5.28" *)
  input [4:0] b;
  wire [4:0] b;
  (* src = "full_adder.sv:6.15-6.18" *)
  input cin;
  wire cin;
  (* src = "full_adder.sv:7.27-7.28" *)
  output [4:0] s;
  wire [4:0] s;
  (* src = "full_adder.sv:8.15-8.19" *)
  output cout;
  wire cout;
  wire _00_;
  wire _01_;
  wire _02_;
  wire _03_;
  wire _04_;
  wire _05_;
  wire _06_;
  wire _07_;
  wire _08_;
  wire _09_;
  wire _10_;
  wire _11_;
  wire _12_;
  wire _13_;
  wire _14_;
  wire _15_;
  (* unused_bits = "1 2 3" *)
  wire [4:0] c;
  (* src = "full_adder.sv:14.10-14.11" *)
  wire [31:0] i;
  assign _00_ = ~(b[0] ^ a[0]);
  assign s[0] = ~(_00_ ^ cin);
  assign _01_ = b[1] ^ a[1];
  assign _02_ = ~(b[0] & a[0]);
  assign _03_ = cin & ~(_00_);
  assign _04_ = _02_ & ~(_03_);
  assign s[1] = ~(_04_ ^ _01_);
  assign _05_ = b[2] ^ a[2];
  assign _06_ = ~(b[1] & a[1]);
  assign _07_ = _01_ & ~(_04_);
  assign _08_ = _06_ & ~(_07_);
  assign s[2] = ~(_08_ ^ _05_);
  assign _09_ = b[3] & a[3];
  assign _10_ = ~(b[3] ^ a[3]);
  assign _11_ = ~(b[2] & a[2]);
  assign _12_ = _05_ & ~(_08_);
  assign _13_ = _11_ & ~(_12_);
  assign _14_ = ~(_13_ | _10_);
  assign cout = _14_ | _09_;
  assign s[3] = _13_ ^ _10_;
  assign _15_ = b[4] ^ a[4];
  assign s[4] = _15_ ^ cout;
  assign { c[4], c[0] } = { cout, cin };
  assign i = 32'd5;
endmodule

(* dynports =  1  *)
(* hdlname = "full_adder" *)
(* src = "full_adder.sv:1.1-33.10" *)
module \$paramod\full_adder\width=s32'00000000000000000000000000000110 (a, b, cin, s, cout);
  (* src = "full_adder.sv:4.27-4.28" *)
  input [5:0] a;
  wire [5:0] a;
  (* src = "full_adder.sv:5.27-5.28" *)
  input [5:0] b;
  wire [5:0] b;
  (* src = "full_adder.sv:6.15-6.18" *)
  input cin;
  wire cin;
  (* src = "full_adder.sv:7.27-7.28" *)
  output [5:0] s;
  wire [5:0] s;
  (* src = "full_adder.sv:8.15-8.19" *)
  output cout;
  wire cout;
  wire _00_;
  wire _01_;
  wire _02_;
  wire _03_;
  wire _04_;
  wire _05_;
  wire _06_;
  wire _07_;
  wire _08_;
  wire _09_;
  wire _10_;
  wire _11_;
  wire _12_;
  wire _13_;
  wire _14_;
  wire _15_;
  wire _16_;
  wire _17_;
  wire _18_;
  wire _19_;
  (* unused_bits = "1 2 3 4" *)
  wire [5:0] c;
  (* src = "full_adder.sv:14.10-14.11" *)
  wire [31:0] i;
  assign _00_ = ~(b[0] ^ a[0]);
  assign s[0] = ~(_00_ ^ cin);
  assign _01_ = b[1] ^ a[1];
  assign _02_ = ~(b[0] & a[0]);
  assign _03_ = cin & ~(_00_);
  assign _04_ = _02_ & ~(_03_);
  assign s[1] = ~(_04_ ^ _01_);
  assign _05_ = b[2] ^ a[2];
  assign _06_ = ~(b[1] & a[1]);
  assign _07_ = _01_ & ~(_04_);
  assign _08_ = _06_ & ~(_07_);
  assign s[2] = ~(_08_ ^ _05_);
  assign _09_ = ~(b[3] ^ a[3]);
  assign _10_ = ~(b[2] & a[2]);
  assign _11_ = _05_ & ~(_08_);
  assign _12_ = _10_ & ~(_11_);
  assign s[3] = _12_ ^ _09_;
  assign _13_ = b[4] & a[4];
  assign _14_ = ~(b[4] ^ a[4]);
  assign _15_ = ~(b[3] & a[3]);
  assign _16_ = ~(_12_ | _09_);
  assign _17_ = _15_ & ~(_16_);
  assign _18_ = ~(_17_ | _14_);
  assign cout = _18_ | _13_;
  assign s[4] = _17_ ^ _14_;
  assign _19_ = b[5] ^ a[5];
  assign s[5] = _19_ ^ cout;
  assign { c[5], c[0] } = { cout, cin };
  assign i = 32'd6;
endmodule

(* dynports =  1  *)
(* hdlname = "full_adder" *)
(* src = "full_adder.sv:1.1-33.10" *)
module \$paramod\full_adder\width=s32'00000000000000000000000000001000 (a, b, cin, s, cout);
  (* src = "full_adder.sv:4.27-4.28" *)
  input [7:0] a;
  wire [7:0] a;
  (* src = "full_adder.sv:5.27-5.28" *)
  input [7:0] b;
  wire [7:0] b;
  (* src = "full_adder.sv:6.15-6.18" *)
  input cin;
  wire cin;
  (* src = "full_adder.sv:7.27-7.28" *)
  output [7:0] s;
  wire [7:0] s;
  (* src = "full_adder.sv:8.15-8.19" *)
  output cout;
  wire cout;
  wire _00_;
  wire _01_;
  wire _02_;
  wire _03_;
  wire _04_;
  wire _05_;
  wire _06_;
  wire _07_;
  wire _08_;
  wire _09_;
  wire _10_;
  wire _11_;
  wire _12_;
  wire _13_;
  wire _14_;
  wire _15_;
  wire _16_;
  wire _17_;
  wire _18_;
  wire _19_;
  wire _20_;
  wire _21_;
  wire _22_;
  wire _23_;
  wire _24_;
  wire _25_;
  wire _26_;
  wire _27_;
  (* unused_bits = "1 2 3 4 5 6" *)
  wire [7:0] c;
  (* src = "full_adder.sv:14.10-14.11" *)
  wire [31:0] i;
  assign _00_ = ~(b[0] ^ a[0]);
  assign s[0] = ~(_00_ ^ cin);
  assign _01_ = b[1] ^ a[1];
  assign _02_ = ~(b[0] & a[0]);
  assign _03_ = cin & ~(_00_);
  assign _04_ = _02_ & ~(_03_);
  assign s[1] = ~(_04_ ^ _01_);
  assign _05_ = b[2] ^ a[2];
  assign _06_ = ~(b[1] & a[1]);
  assign _07_ = _01_ & ~(_04_);
  assign _08_ = _06_ & ~(_07_);
  assign s[2] = ~(_08_ ^ _05_);
  assign _09_ = ~(b[3] ^ a[3]);
  assign _10_ = ~(b[2] & a[2]);
  assign _11_ = _05_ & ~(_08_);
  assign _12_ = _10_ & ~(_11_);
  assign s[3] = _12_ ^ _09_;
  assign _13_ = ~(b[4] ^ a[4]);
  assign _14_ = ~(b[3] & a[3]);
  assign _15_ = ~(_12_ | _09_);
  assign _16_ = _14_ & ~(_15_);
  assign s[4] = _16_ ^ _13_;
  assign _17_ = ~(b[5] ^ a[5]);
  assign _18_ = ~(b[4] & a[4]);
  assign _19_ = ~(_16_ | _13_);
  assign _20_ = _18_ & ~(_19_);
  assign s[5] = _20_ ^ _17_;
  assign _21_ = b[6] & a[6];
  assign _22_ = ~(b[6] ^ a[6]);
  assign _23_ = ~(b[5] & a[5]);
  assign _24_ = ~(_20_ | _17_);
  assign _25_ = _23_ & ~(_24_);
  assign _26_ = ~(_25_ | _22_);
  assign cout = _26_ | _21_;
  assign s[6] = _25_ ^ _22_;
  assign _27_ = b[7] ^ a[7];
  assign s[7] = _27_ ^ cout;
  assign { c[7], c[0] } = { cout, cin };
  assign i = 32'd8;
endmodule

(* dynports =  1  *)
(* hdlname = "mux2" *)
(* src = "mux2.sv:1.1-11.10" *)
module \$paramod\mux2\width=s32'00000000000000000000000000000101 (d0, d1, s, y);
  (* src = "mux2.sv:4.33-4.35" *)
  input [4:0] d0;
  wire [4:0] d0;
  (* src = "mux2.sv:4.37-4.39" *)
  input [4:0] d1;
  wire [4:0] d1;
  (* src = "mux2.sv:5.21-5.22" *)
  input s;
  wire s;
  (* src = "mux2.sv:6.34-6.35" *)
  output [4:0] y;
  wire [4:0] y;
  assign y[0] = s ? d1[0] : d0[0];
  assign y[1] = s ? d1[1] : d0[1];
  assign y[2] = s ? d1[2] : d0[2];
  assign y[3] = s ? d1[3] : d0[3];
  assign y[4] = s ? d1[4] : d0[4];
endmodule

(* dynports =  1  *)
(* hdlname = "mux2" *)
(* src = "mux2.sv:1.1-11.10" *)
module \$paramod\mux2\width=s32'00000000000000000000000000001000 (d0, d1, s, y);
  (* src = "mux2.sv:4.33-4.35" *)
  input [7:0] d0;
  wire [7:0] d0;
  (* src = "mux2.sv:4.37-4.39" *)
  input [7:0] d1;
  wire [7:0] d1;
  (* src = "mux2.sv:5.21-5.22" *)
  input s;
  wire s;
  (* src = "mux2.sv:6.34-6.35" *)
  output [7:0] y;
  wire [7:0] y;
  assign y[0] = s ? d1[0] : d0[0];
  assign y[1] = s ? d1[1] : d0[1];
  assign y[2] = s ? d1[2] : d0[2];
  assign y[3] = s ? d1[3] : d0[3];
  assign y[4] = s ? d1[4] : d0[4];
  assign y[5] = s ? d1[5] : d0[5];
  assign y[6] = s ? d1[6] : d0[6];
  assign y[7] = s ? d1[7] : d0[7];
endmodule

(* src = "energy_counter.sv:1.1-31.10" *)
module energy_count_next(old_clk, people_count, old_energy, next_clk, next_energy);
  (* src = "energy_counter.sv:2.20-2.27" *)
  input [5:0] old_clk;
  wire [5:0] old_clk;
  (* src = "energy_counter.sv:3.20-3.32" *)
  input [4:0] people_count;
  wire [4:0] people_count;
  (* src = "energy_counter.sv:4.20-4.30" *)
  input [7:0] old_energy;
  wire [7:0] old_energy;
  (* src = "energy_counter.sv:6.21-6.29" *)
  output [5:0] next_clk;
  wire [5:0] next_clk;
  (* src = "energy_counter.sv:7.21-7.32" *)
  output [7:0] next_energy;
  wire [7:0] next_energy;
  (* src = "energy_counter.sv:11.7-11.19" *)
  wire is_energy_up;
  (* src = "energy_counter.sv:10.13-10.23" *)
  wire [7:0] new_energy;
  (* src = "energy_counter.sv:13.17-19.2" *)
  \$paramod\full_adder\width=s32'00000000000000000000000000000110  add_clk (
    .a(old_clk),
    .b({ 1'h0, people_count }),
    .cin(1'h0),
    .cout(is_energy_up),
    .s(next_clk)
  );
  (* src = "energy_counter.sv:21.17-27.2" *)
  \$paramod\full_adder\width=s32'00000000000000000000000000001000  add_energy (
    .a(8'h01),
    .b(old_energy),
    .cin(1'h0),
    .s(new_energy)
  );
  (* src = "energy_counter.sv:29.11-29.64" *)
  \$paramod\mux2\width=s32'00000000000000000000000000001000  m1 (
    .d0(old_energy),
    .d1(new_energy),
    .s(is_energy_up),
    .y(next_energy)
  );
endmodule

(* src = "people_counter.sv:1.1-44.10" *)
module people_count_next(current_count, switch_A, switch_B, next_count);
  (* src = "people_counter.sv:3.21-3.34" *)
  input [4:0] current_count;
  wire [4:0] current_count;
  (* src = "people_counter.sv:4.15-4.23" *)
  input switch_A;
  wire switch_A;
  (* src = "people_counter.sv:5.15-5.23" *)
  input switch_B;
  wire switch_B;
  (* src = "people_counter.sv:6.21-6.31" *)
  output [4:0] next_count;
  wire [4:0] next_count;
  (* src = "people_counter.sv:35.35-35.39" *)
  wire _00_;
  wire _01_;
  wire _02_;
  wire _03_;
  wire _04_;
  wire _05_;
  wire _06_;
  wire _07_;
  wire _08_;
  (* src = "people_counter.sv:11.14-11.17" *)
  wire [4:0] add;
  (* src = "people_counter.sv:10.13-10.16" *)
  wire dec;
  (* src = "people_counter.sv:10.8-10.11" *)
  wire inc;
  (* src = "people_counter.sv:12.14-12.19" *)
  wire [4:0] mux_0;
  (* src = "people_counter.sv:12.21-12.26" *)
  wire [4:0] mux_1;
  (* src = "people_counter.sv:11.19-11.22" *)
  wire [4:0] sub;
  assign _01_ = current_count[3] & current_count[4];
  assign _02_ = _01_ & current_count[2];
  assign _03_ = ~(_02_ & current_count[1]);
  assign _04_ = current_count[0] & ~(_03_);
  assign inc = switch_A & ~(_04_);
  assign _00_ = _04_ | ~(switch_A);
  assign _05_ = current_count[3] | current_count[4];
  assign _06_ = _05_ | current_count[2];
  assign _07_ = ~(_06_ | current_count[1]);
  assign _08_ = _07_ & ~(current_count[0]);
  assign dec = switch_B & ~(_08_);
  (* src = "people_counter.sv:18.18-24.3" *)
  \$paramod\full_adder\width=s32'00000000000000000000000000000101  adding (
    .a(current_count),
    .b(5'h01),
    .cin(1'h0),
    .s(add)
  );
  (* src = "people_counter.sv:34.12-34.46" *)
  \$paramod\mux2\width=s32'00000000000000000000000000000101  m0 (
    .d0(current_count),
    .d1(add),
    .s(inc),
    .y(mux_0)
  );
  (* src = "people_counter.sv:35.12-35.47" *)
  \$paramod\mux2\width=s32'00000000000000000000000000000101  m1 (
    .d0(current_count),
    .d1(sub),
    .s(_00_),
    .y(mux_1)
  );
  (* src = "people_counter.sv:36.12-36.45" *)
  \$paramod\mux2\width=s32'00000000000000000000000000000101  m2 (
    .d0(mux_0),
    .d1(mux_1),
    .s(dec),
    .y(next_count)
  );
  (* src = "people_counter.sv:26.18-32.3" *)
  \$paramod\full_adder\width=s32'00000000000000000000000000000101  subtracting (
    .a(current_count),
    .b(5'h1e),
    .cin(1'h1),
    .s(sub)
  );
endmodule

(* src = "sevenseg.sv:1.1-19.10" *)
module sevenseg(data, segments);
  (* src = "sevenseg.sv:1.35-1.39" *)
  input [3:0] data;
  wire [3:0] data;
  (* src = "sevenseg.sv:2.21-2.29" *)
  output [6:0] segments;
  wire [6:0] segments;
  wire _00_;
  wire _01_;
  wire _02_;
  wire _03_;
  wire _04_;
  wire _05_;
  wire _06_;
  wire _07_;
  wire _08_;
  wire _09_;
  wire _10_;
  wire _11_;
  wire _12_;
  wire _13_;
  wire _14_;
  wire _15_;
  wire _16_;
  wire _17_;
  wire _18_;
  assign _00_ = ~data[2];
  assign _01_ = ~(data[0] & data[1]);
  assign _02_ = data[2] ? _01_ : data[1];
  assign _03_ = ~(data[2] | data[1]);
  assign segments[0] = data[3] ? _03_ : _02_;
  assign _04_ = ~(data[0] | data[1]);
  assign _05_ = data[2] ? _01_ : _04_;
  assign segments[1] = data[3] ? _03_ : _05_;
  assign _06_ = _04_ & ~(data[2]);
  assign _07_ = data[1] & ~(data[0]);
  assign _08_ = _04_ | _07_;
  assign _09_ = data[2] ? _07_ : _08_;
  assign segments[2] = data[3] ? _06_ : _09_;
  assign _10_ = data[1] | ~(data[0]);
  assign _11_ = data[0] ^ data[1];
  assign _12_ = data[2] ? _11_ : _10_;
  assign segments[3] = data[3] ? _03_ : _12_;
  assign _13_ = data[0] | ~(data[1]);
  assign _14_ = _13_ | data[2];
  assign segments[4] = data[3] ? _03_ : _14_;
  assign _15_ = ~(data[0] ^ data[1]);
  assign _16_ = _15_ | _00_;
  assign segments[5] = data[3] ? _03_ : _16_;
  assign _17_ = data[0] | data[1];
  assign _18_ = data[2] ? _17_ : _10_;
  assign segments[6] = data[3] ? _03_ : _18_;
endmodule

(* top =  1  *)
(* src = "smart_room.sv:1.1-87.10" *)
module smart_room(clk, reset, switchA, switchB, seg_people, seg_energy, green_leds, red_leds, room_full);
  (* src = "smart_room.sv:2.22-2.25" *)
  input clk;
  wire clk;
  (* src = "smart_room.sv:3.22-3.27" *)
  input reset;
  wire reset;
  (* src = "smart_room.sv:4.22-4.29" *)
  input switchA;
  wire switchA;
  (* src = "smart_room.sv:5.22-5.29" *)
  input switchB;
  wire switchB;
  (* src = "smart_room.sv:6.22-6.32" *)
  output [6:0] seg_people;
  wire [6:0] seg_people;
  (* src = "smart_room.sv:7.22-7.32" *)
  output [6:0] seg_energy;
  wire [6:0] seg_energy;
  (* src = "smart_room.sv:8.22-8.32" *)
  output [3:0] green_leds;
  wire [3:0] green_leds;
  (* src = "smart_room.sv:9.22-9.30" *)
  output [3:0] red_leds;
  wire [3:0] red_leds;
  (* src = "smart_room.sv:10.22-10.31" *)
  output room_full;
  wire room_full;
  wire _00_;
  wire _01_;
  wire _02_;
  wire _03_;
  (* src = "smart_room.sv:19.13-19.20" *)
  reg [5:0] clk_div;
  (* src = "smart_room.sv:20.13-20.25" *)
  wire [5:0] clk_div_next;
  (* src = "smart_room.sv:18.13-18.24" *)
  wire [7:0] energy_next;
  (* src = "smart_room.sv:17.13-17.25" *)
  reg [7:0] energy_usage;
  (* src = "smart_room.sv:14.13-14.25" *)
  reg [4:0] people_count;
  (* src = "smart_room.sv:15.13-15.24" *)
  wire [4:0] people_next;
  assign _01_ = people_count[2] & people_count[3];
  assign _02_ = ~(people_count[1] & people_count[3]);
  assign _03_ = people_count[0] & ~(_02_);
  assign _00_ = _03_ | _01_;
  assign room_full = _00_ | people_count[4];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:31.1-36.4" *)
  always @(posedge clk, posedge reset)
    if (reset) people_count[0] <= 1'h0;
    else people_count[0] <= people_next[0];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:31.1-36.4" *)
  always @(posedge clk, posedge reset)
    if (reset) people_count[1] <= 1'h0;
    else people_count[1] <= people_next[1];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:31.1-36.4" *)
  always @(posedge clk, posedge reset)
    if (reset) people_count[2] <= 1'h0;
    else people_count[2] <= people_next[2];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:31.1-36.4" *)
  always @(posedge clk, posedge reset)
    if (reset) people_count[3] <= 1'h0;
    else people_count[3] <= people_next[3];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:31.1-36.4" *)
  always @(posedge clk, posedge reset)
    if (reset) people_count[4] <= 1'h0;
    else people_count[4] <= people_next[4];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:49.1-60.4" *)
  always @(posedge clk, posedge reset)
    if (reset) clk_div[0] <= 1'h0;
    else clk_div[0] <= clk_div_next[0];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:49.1-60.4" *)
  always @(posedge clk, posedge reset)
    if (reset) clk_div[1] <= 1'h0;
    else clk_div[1] <= clk_div_next[1];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:49.1-60.4" *)
  always @(posedge clk, posedge reset)
    if (reset) clk_div[2] <= 1'h0;
    else clk_div[2] <= clk_div_next[2];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:49.1-60.4" *)
  always @(posedge clk, posedge reset)
    if (reset) clk_div[3] <= 1'h0;
    else clk_div[3] <= clk_div_next[3];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:49.1-60.4" *)
  always @(posedge clk, posedge reset)
    if (reset) clk_div[4] <= 1'h0;
    else clk_div[4] <= clk_div_next[4];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:49.1-60.4" *)
  always @(posedge clk, posedge reset)
    if (reset) clk_div[5] <= 1'h0;
    else clk_div[5] <= clk_div_next[5];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:49.1-60.4" *)
  always @(posedge clk, posedge reset)
    if (reset) energy_usage[0] <= 1'h0;
    else energy_usage[0] <= energy_next[0];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:49.1-60.4" *)
  always @(posedge clk, posedge reset)
    if (reset) energy_usage[1] <= 1'h0;
    else energy_usage[1] <= energy_next[1];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:49.1-60.4" *)
  always @(posedge clk, posedge reset)
    if (reset) energy_usage[2] <= 1'h0;
    else energy_usage[2] <= energy_next[2];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:49.1-60.4" *)
  always @(posedge clk, posedge reset)
    if (reset) energy_usage[3] <= 1'h0;
    else energy_usage[3] <= energy_next[3];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:49.1-60.4" *)
  always @(posedge clk, posedge reset)
    if (reset) energy_usage[4] <= 1'h0;
    else energy_usage[4] <= energy_next[4];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:49.1-60.4" *)
  always @(posedge clk, posedge reset)
    if (reset) energy_usage[5] <= 1'h0;
    else energy_usage[5] <= energy_next[5];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:49.1-60.4" *)
  always @(posedge clk, posedge reset)
    if (reset) energy_usage[6] <= 1'h0;
    else energy_usage[6] <= energy_next[6];
  (* \always_ff  = 32'd1 *)
  (* src = "smart_room.sv:49.1-60.4" *)
  always @(posedge clk, posedge reset)
    if (reset) energy_usage[7] <= 1'h0;
    else energy_usage[7] <= energy_next[7];
  (* module_not_derived = 32'd1 *)
  (* src = "smart_room.sv:39.19-45.2" *)
  energy_count_next e_count (
    .next_clk(clk_div_next),
    .next_energy(energy_next),
    .old_clk(clk_div),
    .old_energy(energy_usage),
    .people_count(people_count)
  );
  (* module_not_derived = 32'd1 *)
  (* src = "smart_room.sv:82.11-85.3" *)
  sevenseg energy (
    .data(energy_usage[3:0]),
    .segments(seg_energy)
  );
  (* module_not_derived = 32'd1 *)
  (* src = "smart_room.sv:24.19-29.2" *)
  people_count_next p_count (
    .current_count(people_count),
    .next_count(people_next),
    .switch_A(switchA),
    .switch_B(switchB)
  );
  (* module_not_derived = 32'd1 *)
  (* src = "smart_room.sv:78.11-81.3" *)
  sevenseg people (
    .data(people_count[3:0]),
    .segments(seg_people)
  );
  assign green_leds = people_count[4:1];
  assign red_leds = people_count[4:1];
endmodule
